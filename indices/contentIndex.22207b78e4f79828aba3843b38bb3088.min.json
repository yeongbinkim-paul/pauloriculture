{"/":{"title":"🪴 Pauloriculture","content":"성실한 기록부자를 꿈꿉니다.\nDreaming of being a diligent record keeper.\n","lastmodified":"2023-07-01T00:21:00.072322105Z","tags":null},"/notes/data_engineering/pandas_as_an_sql_en":{"title":"[DE] Pandas As an SQL (EN)","content":"\n\n## Pandas as an SQL\nDate : June 20, 2023\n\nI studied PANDAS as an SQL Statement\n```sql\nSELECT\n    table.a,\n    table.b as b1,\n    table2.c as c1,\n    table2.d,\n    sum(table2.e) as e1\nFROM table\nLEFT JOIN table2\nON table.a = table2.a\nWHERE true\n  AND table.a \u003e 0\n  AND (table.b = \"None\" or table2.c \u003e 0)\nGROUP BY table.a, table.b, table2.c, table2.d\nHAVING f1 \u003e 0\nORDER BY table.a ASC, table.b DESC, table2.c ASC\nLIMIT 100\nOFFSET 10\n```\nIf you were to write a query above in Pandas, you would write it like a code below:\n\n```python\nimport pandas as pd\n\ntable = pd.DataFrame(\n    {\n        'a': [1,2,3],\n        'b': [\"4\",\"4\",\"6\"],\n    }\n)\n\ntable2 = pd.DataFrame(\n        {\n                'a': [1,2,3],\n                'c': [1,2,3],\n                'd': [\"4\",\"6\",\"4\"],\n                'e': [1,2,3],\n        }\n)\n\nresult = (\n    table.merge(table2, on='a', how='left') # Join\n        [['a', 'b', 'c', 'd', 'e'] ] # Select\n        .rename(columns={'b': 'b1', 'c': 'c1'}) # Alias\n        .query('a \u003e 0 \u0026 (b1 == \"None\" | c1 \u003e 0)') # Where\n        .groupby(['a', 'b1', 'c1', 'd', 'e']) # Group by\n        .agg(\n                e1 = ('e', 'sum')\n        ) # Aggregation\n        .reset_index() # Reset Index - without this, the dataframe has multiple index consisted of columns which were used in group by statement\n        .query('e1 \u003e= 0') # Having\n        .sort_values(['a', 'b1', 'c1'], ascending=[True, False, True]) # Order by\n        .iloc[10:110] # limit and offset\n)\n\n```\n","lastmodified":"2023-07-01T00:21:00.072322105Z","tags":null},"/notes/data_engineering/pandas_as_an_sql_kr":{"title":"[DE] Pandas As an SQL (KR)","content":"\n\n## SQL처럼 쓰는 Pandas\n작성 일자 : 2023년 6월 20일\n\nPandas를 SQL문처럼 공부해봤습니다.\n```sql\nSELECT\n    table.a,\n    table.b as b1,\n    table2.c as c1,\n    table2.d,\n    sum(table2.e) as e1\nFROM table\nLEFT JOIN table2\nON table.a = table2.a\nWHERE true\n  AND table.a \u003e 0\n  AND (table.b = \"None\" or table2.c \u003e 0)\nGROUP BY table.a, table.b, table2.c, table2.d\nHAVING f1 \u003e 0\nORDER BY table.a ASC, table.b DESC, table2.c ASC\nLIMIT 100\nOFFSET 10\n```\n이라는 쿼리를 Pandas로 작성한다면, 아래와 같이 코드를 작성합니다.\n\n```python\nimport pandas as pd\n\ntable = pd.DataFrame(\n    {\n        'a': [1,2,3],\n        'b': [\"4\",\"4\",\"6\"],\n    }\n)\n\ntable2 = pd.DataFrame(\n        {\n                'a': [1,2,3],\n                'c': [1,2,3],\n                'd': [\"4\",\"6\",\"4\"],\n                'e': [1,2,3],\n        }\n)\n\nresult = (\n    table.merge(table2, on='a', how='left') # Join\n        [['a', 'b', 'c', 'd', 'e'] ] # Select\n        .rename(columns={'b': 'b1', 'c': 'c1'}) # Alias\n        .query('a \u003e 0 \u0026 (b1 == \"None\" | c1 \u003e 0)') # Where\n        .groupby(['a', 'b1', 'c1', 'd', 'e']) # Group by\n        .agg(\n                e1 = ('e', 'sum')\n        ) # Aggregation\n        .reset_index() # Reset Index - without this, the dataframe has multiple index consisted of columns which were used in group by statement\n        .query('e1 \u003e= 0') # Having\n        .sort_values(['a', 'b1', 'c1'], ascending=[True, False, True]) # Order by\n        .iloc[10:110] # limit and offset\n)\n\n```\n","lastmodified":"2023-07-01T00:21:00.072322105Z","tags":null},"/notes/dune_nft/market_overview_en":{"title":"[Dune] NFT Market Overview Chart Review (EN)","content":"\n\n## Market Overview Chart Review\nDate : March 22, 2023\n\nReviewed [NFT Market Overview](https://dune.com/hildobby/NFTs)\n\n### 1. Overview\n\n![Screenshot](/notes/dune_nft/images/market_overview/01_overview.png)\n\nYou can see that we have constructed a pie chart using **Volume / Number of trades / Number of traders**.\n\nGiven that the amount of data is large by default, and that more recent data is more meaningful for trading, they show the most recent 1-week data.\nThe trade column in the **NFT Collection Ranked by Volume** chart below are links to actual tradeable websites, so they don't mean much.\n\n### 2. Volume\n\n![Screenshot](/notes/dune_nft/images/market_overview/02_volume.png)\n\nTrading volume is organized into Bar Chart and Stacked Area Chart, each of which allows you to view Daily Volume and Weekly Volume.\n\nThe Bar Chart is a great way to see total volume, so you can see overall volume trends and time series of marketplace share.\nThe Stacked Area Chart is an intuitive representation of the share seen in this Bar Chart.\n\n\n\n### 3. Transactions\n\n![Screenshot](/notes/dune_nft/images/market_overview/03_transactions.png)\n\nThe transactions chart is organized the same as the volume chart, with the numbers in each chart representing the number of transactions.\n\nIf you compare the number of trades chart to the volume chart, you can see that Blur's volume has recently spiked and surpassed Opensea's volume, but that hasn't translated to the number of trades. We can assume that there are still a lot of active users on Opensea.\n\n### 4. Traders\n\n![Screenshot](/notes/dune_nft/images/market_overview/04_traders.png)\n\nThis chart shows the number of wallets that have traded NFTs.\n\nIn this case, They used a Line Chart instead of a Stacked Area Chart. I thought it's better to use a Stacked Area Chart, so I made Stacked Area Chart for comparison\n\n![Screenshot](/notes/dune_nft/images/market_overview/04_1_traders_area.png)\n\nI was able to see these results, and there are a few takeaways from this comparison.\n\n1. Stacked Area Chart has the advantage of visualizing occupancy rates.\n2. Line charts allow you to visualize the share, but also to see how the value changes over time. For example, you can observe a sharp drop in the number of traders in March.\n3. However, the Traders chart is different from the other charts in that the Bar Chart counts the number of trading wallets by date, while the Line Chart counts the number of trading wallets by marketplace. Since there may be wallets that use multiple marketplaces at the same time, it is important to keep this in mind when organizing the chart.\n\n![Screenshot](/notes/dune_nft/images/market_overview/04_2_traders_area_2.png)\nIf you compare the screenshot above with the Bar Chart in the Dashboard, you can see that the values on the y-axis are different.\n\n### 5. Token Standards\n\n![Screenshot](/notes/dune_nft/images/market_overview/05_token_standards.png)\n\nThese Charts show Volume, Trade Count, and Trader Count by Token Standard.\n\nThis is where the question arose.\nIn the case of ERC721, you can only trade one token per token id, whereas ERC1155 allows you to trade multiple.\nAlso, Opensea allows bundle trade, so I was wondering how to calculate the price of nfts in these situation.\n\nSo I looked into Dune Spellbook. [링크](https://dune.com/spellbook#!/model/model.spellbook.seaport_v2_ethereum_trades)\n![Screenshot](/notes/dune_nft/images/market_overview/06_spellbook_opensea.png)\n\nAs you can see in the screenshot above, if multiple NFTs were traded in a particular trade, we were able to categorize it as a bundle trade and then split the trade price equally.\nThis tells us the following:\n\n- The opensea trades included in the nft trades dataset used by Dune are calculated by dividing the total price of the individual purchases of nft in a trade by the number of nft in the trade.\n- As a result, some transaction value data was calculated incorrectly.\n- However, in bundle transactions, the seller estimates the individual prices of the NFTs in the bundle and sells them together, and the same applies to the buyer, so there is no problem with using this data unless there is an accounting requirement for both the seller and buyer.\n\n## Further Study\n\nWhile researching Spellbook, something occurred to me that I wanted to investigate further.\nI've seen that it's difficult to estimate the exact purchase price for bundle transactions on Opensea.\nI want to see how Dune Analytics estimate the purchase price for transactions from market aggregators like Gem and Blur that sweep listings from multiple marketplaces\n","lastmodified":"2023-07-01T00:21:00.084322279Z","tags":null},"/notes/dune_nft/market_overview_kr":{"title":"[Dune] NFT Market Overview Chart Review (KR)","content":"\n\n## Market Overview 차트 리뷰\n작성 일자 : 2023년 3월 22일\n\n[NFT Market Overview](https://dune.com/hildobby/NFTs)를 리뷰해봤습니다.\n\n### 1. Overview\n\n![Screenshot](/notes/dune_nft/images/market_overview/01_overview.png)\n\n**거래량 / 거래 횟수 / 거래자 수**를 이용해 파이차트를 구성한 것을 확인할 수 있습니다.\n\n데이터 양이 기본적으로 많고, 최신 데이터가 Trading에 좀 더 유의미하다는 점을 감안해, 최근 1주 데이터를 보여줍니다.\n하단 **NFT Collection Ranked by Volume** 차트의 Trade는 실제 trade 가능한 웹사이트의 링크라서 큰 의미는 없습니다.\n\n### 2. Volume\n\n![Screenshot](/notes/dune_nft/images/market_overview/02_volume.png)\n\n거래량은 Bar Chart와 Stacked Area Chart로 구성되어 있고, 각각은 Daily Volume과 Weekly Volume을 볼 수 있습니다.\n\nBar Chart는 거래량 총합을 확인할 수 있다는 점에서 전반적인 거래량 추이와 시계열로 Marketplace 별 점유율을 가늠할 수 있습니다.\nStacked Area Chart는 이 Bar Chart에서 확인한 점유율을 직관적으로 표현한 것입니다.\n\n### 3. Transactions\n\n![Screenshot](/notes/dune_nft/images/market_overview/03_transactions.png)\n\n거래 횟수는 거래량 차트와 동일하게 구성되어 있고, 각 차트의 수치는 거래 횟수를 의미합니다.\n\n거래 횟수 차트를 거래량 차트와 비교해서 보면, 최근 Blur의 거래량이 급등해 Opensea의 거래량을 크게 넘어섰지만, 그것이 거래 횟수까지 이어지지는 않은 것을 알 수 있습니다. 아직 Opensea의 활성화 유저가 많이 남아있음을 추측할 수 있습니다.\n\n### 4. Traders\n\n![Screenshot](/notes/dune_nft/images/market_overview/04_traders.png)\n\n이 Chart는 NFT를 거래한 지갑의 수 추이를 보여줍니다.\n\n이 경우에는 Stacked Area Chart 대신, Line Chart를 사용했는데, Stacked Area Chart를 사용하는 것이 더 좋다는 생각이 들어 비교해 보고자 직접 Chart를 작성해 봤습니다.\n\n![Screenshot](/notes/dune_nft/images/market_overview/04_1_traders_area.png)\n\n이러한 결과를 볼 수 있었는데, 이 차트와 기존 차트를 비교해 보고 몇 가지 takeaway를 얻을 수 있었습니다.\n1. Stacked Area Chart를 사용하면 점유율을 시각화 하는 것에 장점이 있다.\n2. Line Chart를 사용하면 점유율을 시각화하는 동시에, 시계열에 따른 값 변화 차이를 잘 볼 수 있다. 예를 들어, 3월에 급격히 거래자 수가 급감한 시기를 관찰하는 것이 가능하다.\n3. 다만 Traders 차트는 다른 차트와 달리 주의할 점이 있었는데, Bar Chart의 경우는 날짜별 거래 지갑 수를 센 반면, Line Chart에서는 Marketplace 별로 거래 지갑 수를 세고 있다. 여러 Marketplace를 동시에 이용한 지갑이 존재할 수 있기 때문에, 차트 구성 시 유의하면 좋다.\n\n![Screenshot](/notes/dune_nft/images/market_overview/04_2_traders_area_2.png)\n위 스크린샷과 Dashboard의 Bar Chart를 비교해보면 y축의 값이 다른 것을 알 수 있습니다.\n\n### 5. Token Standards\n\n![Screenshot](/notes/dune_nft/images/market_overview/05_token_standards.png)\n\nToken Standard 별로 Volume, Trade Count, Trader Count를 표기한 것입니다.\n\n여기에서 궁금증이 생겼습니다.\nEERC721의 경우에는 token id 별로 1개만 거래 가능한 데에 반해, ERC1155는 여러 개를 거래할 수 있습니다.RC721의 경우에는 1개만 거래하는 데에 반해, ERC1155는 여러개를 거래할 수 있습니다.\n더불어, Opensea의 경우, Bundle 거래가 가능해 그 거래 Volume을 어떻게 잡는 지 궁금했습니다.\n\n그래서 Spellbook을 조사해봤습니다. [링크](https://dune.com/spellbook#!/model/model.spellbook.seaport_v2_ethereum_trades)\n![Screenshot](/notes/dune_nft/images/market_overview/06_spellbook_opensea.png)\n\n위 스크린샷에서 볼 수 있듯이, 특정 거래에서 nft가 여러 개 거래되는 경우에는 bundle 거래로 분류한 다음, 거래 대금을 균등하게 나누는 것을 확인할 수 있었습니다.\n이를 통해 다음과 같은 사실을 알 수 있습니다.\n\n- Dune에서 사용하는 nft trades dataset에 포함된 opensea 거래는 한 거래에 포함된 nft들의 개별 구매 대금을 전체 대금에서 거래에 포함된 nft의 개수로 나눠서 계산한다.\n- 따라서, 일부 거래 대금 데이터는 부정확하게 계산되었다.\n- 다만, 실제로도 Bundle 거래가 일어날 경우에는 판매자 역시 Bundle에 포함된 NFT들의 개별 가격을 추정한 다음 합산해서 판매하고, 이는 구매자 입장에서도 동일하게 적용되기 때문에, 실제 판매자와 구매자 입장에서는 회계 처리가 필요한 상황이 아니라면 본 데이터를 사용하는 것에 큰 문제가 없다.\n\n## Further Study\n\nSpellbook을 조사하는 과정에서 좀 더 조사하고 싶은 것이 생겼습니다.\nOpensea에서 발생한 Bundle 거래는 정확한 구매 대금을 추정하기 어렵다는 사실은 확인했는데,\nGem, Blur와 같은 Market Aggregator에서 여러 Marketplace의 Listing을 Sweep하는 거래의 경우는 어떻게 구매 대금을 산정하는 지 확인해보려고 합니다.\n","lastmodified":"2023-07-01T00:21:00.084322279Z","tags":null},"/private/study/algorithm":{"title":"Algorithm","content":"\n\n## 이진탐색 문제\n- 구해야 하는 값과, 그 값에 따라 정해지는 변수 값들에 대한 최적화가 필요할 때 방정식 또는 부등식의 형태로 정의할 수 있는 문제는 이진 탐색으로 해결합니다.\n- 가장 대표적인 문제는 대기열에 서있는 n명의 사람들과 이 대기열을 소화할 수 있는 각기 다른 처리 시간을 가진 처리기 집합을 놓고, 처리 가능한 최소 시간을 구하는 문제입니다.\n- 이 경우에는 최소 시간을 목적값으로 하고, 이 최소 시간에 따라 각 처리기가 처리하는 사람의 수를 역으로 찾는 과정에서 효율적인 처리를 위해 최소 시간이 가질 수 있는 최대 값에서부터 이진 탐색으로 최소 시간을 추정하는 방식으로 알고리즘을 해결해야 합니다.\n","lastmodified":"2023-07-01T00:21:00.084322279Z","tags":null},"/private/study/data_engineering":{"title":"Airflow","content":"\n\n## Airflow on Kubernetes 배포하기 (on M1 Mac)\n- m1에 minikube 설치하기 [참조](https://velog.io/@pinion7/macOs-m1-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-kubernetes-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0)\n    ```shell\n    $ curl -Lo minikube https://github.com/kubernetes/minikube/releases/download/v1.25.1/minikube-darwin-arm64 \\\n  \u0026\u0026 chmod +x minikube\n    ```\n    ```shell\n    $ sudo install minikube /usr/local/bin/minikube\n    ```\n- heml, kubectl 설치하기\n    ```shell\n    $ brew install helm, kubectl\n    ```\n- minikube 시작\n    ```shell\n    $ minikube start --driver=docker\n    ```\n- helm repo 추가\n    ```shell\n    $ helm repo add apache-airflow https://airflow.apache.org\n    $ helm repo update\n    ```\n- airflow chart 설치\n    ```shell\n    $ helm install $RELEASE_NAME apache-airflow/airflow --namespace $NAMESPACE --debug\n    ```\n- webserver port-forwarding\n    ```shell\n    $ kubectl port-forward svc/airflow-webserver 8080:8080 --namespace $NAMESPACE\n    ```\n","lastmodified":"2023-07-01T00:21:00.084322279Z","tags":null},"/private/study/sql":{"title":"SQL","content":"\n\n## Rollup Query\n- 사용 방법: SUM(COLUMN_2) ... GROUP BY COLUMN_1, ROLLUP(COLUMN_1)\n- 결과: Column 1 별 Column 2의 SUM 결과들이 표현되면서 그 다음 Row에 SUM 결과들의 합도 표현된다.\n","lastmodified":"2023-07-01T00:21:00.084322279Z","tags":null}}